#[derive(Debug, PartialEq, Eq, Clone, Hash)]
#[allow(dead_code)]
pub enum Token {
    ILLEGAL,
    EOF,
    IDENT(String),
    INT(i32),
    ASSIGN,
    PLUS,
    MINUS,
    BANG,
    ASTERISK,
    SLASH,
    LT,
    GT,
    EQ,
    NOTEQ,
    COMMA,
    SEMICOLON,
    LPAREM,
    RPAREM,
    LBRACE,
    RBRACE,
    FUNCTION,
    LET,
    TRUE,
    FALSE,
    IF,
    ELSE,
    RETURN,
}

impl Token {
    pub fn literal(&self) -> String {
        match self {
            Token::IDENT(ref id) => id.to_string(),
            Token::INT(ref i) => i.to_string(),
            Token::LET => String::from("let"),
            Token::ASSIGN => String::from("="),
            Token::PLUS => String::from("+"),
            Token::MINUS => String::from("-"),
            Token::BANG => String::from("!"),
            Token::ASTERISK => String::from("*"),
            Token::SLASH => String::from("/"),
            Token::LT => String::from("<"),
            Token::GT => String::from(">"),
            Token::EQ => String::from("=="),
            Token::NOTEQ => String::from("!="),
            Token::COMMA => String::from(","),
            Token::SEMICOLON => String::from(";"),
            Token::LPAREM => String::from("("),
            Token::RPAREM => String::from(")"),
            Token::LBRACE => String::from("{"),
            Token::RBRACE => String::from("}"),
            Token::FUNCTION => String::from("fnnction"),
            Token::TRUE => String::from("true"),
            Token::FALSE => String::from("false"),
            Token::IF => String::from("if"),
            Token::ELSE => String::from("else"),
            Token::RETURN => String::from("return"),
            Token::NOTEQ => String::from("!="),
            Token::ILLEGAL => String::from("ILLEGAL"),
            Token::EOF => String::from('\0'),
        }
    }
}
